#!/usr/bin/env python3
"""GitLab REST API v4 client â€” works with GitLab.com and self-managed instances.

Env: GITLAB_URL, GITLAB_TOKEN (required). GITLAB_PROJECT (optional, auto-detected from git remote).
"""

import json
import os
import re
import subprocess
import sys
import urllib.error
import urllib.parse
import urllib.request

sys.dont_write_bytecode = True


def die(msg):
    print(f"error: {msg}", file=sys.stderr)
    sys.exit(1)


GITLAB_URL = os.environ.get("GITLAB_URL", "")
GITLAB_TOKEN = os.environ.get("GITLAB_TOKEN", "")

if not GITLAB_URL:
    die("GITLAB_URL is not set")
if not re.match(r"^https?://", GITLAB_URL):
    die("GITLAB_URL must start with https:// (or http:// for local dev)")
if not GITLAB_TOKEN:
    die("GITLAB_TOKEN is not set")

API = GITLAB_URL.rstrip("/") + "/api/v4"


def _project():
    proj = os.environ.get("GITLAB_PROJECT", "")
    if proj:
        return urllib.parse.quote(proj, safe="")
    try:
        url = subprocess.check_output(
            ["git", "remote", "get-url", "origin"], stderr=subprocess.DEVNULL, text=True
        ).strip()
    except (subprocess.CalledProcessError, FileNotFoundError):
        die("GITLAB_PROJECT not set and no git remote found")

    if url.startswith("git@"):
        path = url.split(":", 1)[1]
    elif re.match(r"^https?://", url):
        path = re.sub(r"^https?://[^/]*/", "", url)
    else:
        die(f"cannot parse git remote URL: {url}")

    path = path.removesuffix(".git")
    if not path:
        die(f"cannot extract project path from remote: {url}")
    return urllib.parse.quote(path, safe="")


def _validate_id(value):
    if not re.match(r"^\d+$", value):
        die(f"expected numeric ID, got: {value}")


def _validate_positive_int(value, label="value"):
    if not re.match(r"^\d+$", value):
        die(f"{label} must be a positive integer, got: {value}")


def _request(method, url, data=None, quiet=False):
    headers = {
        "PRIVATE-TOKEN": GITLAB_TOKEN,
        "Content-Type": "application/json",
        "Accept": "application/json",
    }
    body = json.dumps(data).encode() if data is not None else None
    req = urllib.request.Request(url, data=body, headers=headers, method=method)
    try:
        with urllib.request.urlopen(req) as resp:
            raw = resp.read().decode()
    except urllib.error.HTTPError as e:
        raw = e.read().decode()
        try:
            d = json.loads(raw)
            print(d.get("message", d.get("error", d)), file=sys.stderr)
        except (json.JSONDecodeError, ValueError):
            print(raw, file=sys.stderr)
        die(f"HTTP {e.code} from {method} {url}")

    if not raw.strip():
        return None
    try:
        parsed = json.loads(raw)
    except (json.JSONDecodeError, ValueError):
        print(raw)
        return None
    if not quiet:
        print(json.dumps(parsed, indent=2))
    return parsed


FIELDS = None
for i, a in enumerate(sys.argv):
    if a == "--fields" and i + 1 < len(sys.argv):
        FIELDS = sys.argv[i + 1].split(",")
        sys.argv.pop(i)  # remove --fields
        sys.argv.pop(i)  # remove the value
        break


def _extract(obj, path):
    """Extract a value using dot-notation (e.g. 'author.name')."""
    for part in path.split("."):
        if isinstance(obj, dict):
            obj = obj.get(part)
        else:
            return ""
    if obj is None:
        return ""
    if isinstance(obj, list):
        return ", ".join(str(x) for x in obj)
    return str(obj)


def _print_fields(data):
    """Print extracted fields for a single item or a list of items."""
    if isinstance(data, list):
        # Header
        print("\t".join(FIELDS))
        for item in data:
            print("\t".join(_extract(item, f) for f in FIELDS))
    else:
        for f in FIELDS:
            print(f"{f}: {_extract(data, f)}")


# --- Merge Request commands ---


def cmd_mr_list(args):
    state = args[0] if args else "all"
    max_results = args[1] if len(args) > 1 else "20"
    _validate_positive_int(max_results, "max_results")
    data = _request("GET", f"{API}/projects/{_project()}/merge_requests?state={state}&per_page={max_results}&order_by=created_at&sort=desc", quiet=bool(FIELDS))
    if FIELDS and data:
        _print_fields(data)


def cmd_mr_get(args):
    if not args:
        die("usage: gitlab mr-get <mr-iid>")
    iid = args[0]
    _validate_id(iid)
    data = _request("GET", f"{API}/projects/{_project()}/merge_requests/{iid}", quiet=bool(FIELDS))
    if FIELDS and data:
        _print_fields(data)


def cmd_mr_create(args):
    data = args[0] if args else sys.stdin.read().strip()
    if not data:
        die("usage: gitlab mr-create <json> or pipe JSON to stdin")
    _request("POST", f"{API}/projects/{_project()}/merge_requests", json.loads(data))


def cmd_mr_update(args):
    if not args:
        die("usage: gitlab mr-update <mr-iid> <json>")
    iid = args[0]
    _validate_id(iid)
    data = args[1] if len(args) > 1 else sys.stdin.read().strip()
    if not data:
        die("usage: gitlab mr-update <mr-iid> <json> or pipe JSON to stdin")
    _request("PUT", f"{API}/projects/{_project()}/merge_requests/{iid}", json.loads(data))


def cmd_mr_comment(args):
    if not args:
        die("usage: gitlab mr-comment <mr-iid> <body>")
    iid = args[0]
    _validate_id(iid)
    body = args[1] if len(args) > 1 else sys.stdin.read().strip()
    if not body:
        die("usage: gitlab mr-comment <mr-iid> <body> or pipe body to stdin")
    _request("POST", f"{API}/projects/{_project()}/merge_requests/{iid}/notes", {"body": body})


def cmd_mr_notes(args):
    if not args:
        die("usage: gitlab mr-notes <mr-iid> [max]")
    iid = args[0]
    _validate_id(iid)
    max_results = args[1] if len(args) > 1 else "100"
    _validate_positive_int(max_results, "max_results")
    data = _request("GET", f"{API}/projects/{_project()}/merge_requests/{iid}/notes?per_page={max_results}&sort=asc", quiet=bool(FIELDS))
    if FIELDS and data:
        # Filter out system notes by default
        notes = [n for n in data if not n.get("system", False)]
        _print_fields(notes)


# --- Pipeline & Job commands ---


def cmd_pipeline_get(args):
    if not args:
        die("usage: gitlab pipeline-get <pipeline-id>")
    pid = args[0]
    _validate_id(pid)
    data = _request("GET", f"{API}/projects/{_project()}/pipelines/{pid}", quiet=bool(FIELDS))
    if FIELDS and data:
        _print_fields(data)


def cmd_pipeline_run(args):
    if not args:
        die("usage: gitlab pipeline-run <branch-or-tag>")
    ref = args[0]
    _request("POST", f"{API}/projects/{_project()}/pipelines", {"ref": ref})


def cmd_pipeline_jobs(args):
    if not args:
        die("usage: gitlab pipeline-jobs <pipeline-id>")
    pid = args[0]
    _validate_id(pid)
    data = _request("GET", f"{API}/projects/{_project()}/pipelines/{pid}/jobs", quiet=bool(FIELDS))
    if FIELDS and data:
        _print_fields(data)


def cmd_job_log(args):
    if not args:
        die("usage: gitlab job-log <job-id>")
    jid = args[0]
    _validate_id(jid)
    url = f"{API}/projects/{_project()}/jobs/{jid}/trace"
    headers = {"PRIVATE-TOKEN": GITLAB_TOKEN}
    req = urllib.request.Request(url, headers=headers, method="GET")
    try:
        with urllib.request.urlopen(req) as resp:
            print(resp.read().decode())
    except urllib.error.HTTPError as e:
        print(e.read().decode(), file=sys.stderr)
        die(f"HTTP {e.code} fetching job log")


# --- Dispatch ---

COMMANDS = {
    "mr-list": cmd_mr_list,
    "mr-get": cmd_mr_get,
    "mr-create": cmd_mr_create,
    "mr-update": cmd_mr_update,
    "mr-comment": cmd_mr_comment,
    "mr-notes": cmd_mr_notes,
    "pipeline-get": cmd_pipeline_get,
    "pipeline-run": cmd_pipeline_run,
    "pipeline-jobs": cmd_pipeline_jobs,
    "job-log": cmd_job_log,
}

if len(sys.argv) < 2 or sys.argv[1] not in COMMANDS:
    die("usage: gitlab {mr-list|mr-get|mr-create|mr-update|mr-comment|mr-notes|pipeline-get|pipeline-run|pipeline-jobs|job-log} [args...]")

COMMANDS[sys.argv[1]](sys.argv[2:])
